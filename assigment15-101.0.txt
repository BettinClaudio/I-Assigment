def welcome_message					# La funzione restituisce una stringa che dice "Benvenuto"
  return "Benvenuto"
end

# Restituisce n! (fattoriale)		# La funzione restituisce il fattoriale di n
def factorial(n)
  if n == 0
    return 1
  else
    if n>0
	  tot=1
  	  (1..n).each do |i|
	    tot = tot * i
	  end
	  return tot
  	else
  	  puts "Il valore inserito non è un numero maggiore o uguale a 0"
  	end
  end
end

def find_longest_string(array)						#La funzione restituisce la stringa più lunga in un array di stringhe
  max=[]											#Inizialmente abbiamo implementato la funzione in modo
  max << ""											#che nel caso ce ne siano più di una con il numero
  array.map do |word|								#massimo di caratteri restituisca tutte le stringhe
    if word.length == max.last.length				#di quella lunghezza.
      max << word
    end
    if word.length > max.last.length
      max=[]
      max << word
    end
  end
  if max.last==""
    puts "L'array è vuoto o ha tutti gli elementi stringhe vuote"
  else												#Per rispettare la consegna abbiamo stampato unasola/l'unica stringa
    return max[0] 									#Per avere tutte le stringhe basta sostituire 'max[0]' con 'max'
  end												
end

def has_nested_array?(array)						#La funzione restituisce true se l'array contiene altri array
  array.each do |element|
    if element.class == Array
      return TRUE
    end
  end
  return FALSE
end

def count_upcased_letters(string)					#La funzione conta il numero di caratteri maiuscoli in una stringa
  i = 0
  array_caratteri = string.chars.to_a
  array_caratteri.each do |carattere|
    if (carattere != carattere.downcase)  			#Verifica quali caratteri vengono modificati dalla funzione '.downcase'
      i=i+1											#in quanto solo i caratteri mauiscoli vengono modificati
    else
      next
    end
  end
  return i
end

def to_roman(n)										#La funzione converte un numero in un numero romano
  if n<=0
	puts("I numeri negativi non sono convertibili in numeri romani")
	return nil
  end
  #n = gets.chomp.to_i
  num=""
  i = n/1000
  if(i>0)
    (1..i).each {|v| num << 'M'}
  end
  n = n%1000 										#n ora è il numero inserito senza le mgliaia
  i = n/100
  case i
    when 1 
      num << 'C'
    when 2
      num << 'CC'
    when 3 
      num << 'CCC'
    when 4 
      num << 'CD'
    when 5 
      num << 'D'
    when 6 
      num << 'DC'
    when 7 
      num << 'DCC'
    when 8 
      num << 'DCCC'
    when 9 
      num << 'CM'
  end
  n = n%100											#da qui in poi n è il numero senza le migliaia e centinaia
  i = n/10
  case i
    when 1 
      num << 'X'
    when 2 
      num << 'XX'
    when 3 
      num << 'XXX'
    when 4
      num << 'XL'
    when 5 
      num << 'L'
    when 6 
      num << 'XL'
    when 7 
      num << 'LXX'
    when 8 
      num << 'LXXX'
    when 9 
      num << 'XC'
  end
  n = n%10											#ora rimangono solo le unità
  i = n/1
  case n
    when 1 
      num << 'I'
    when 2 
      num << 'II'
    when 3 
      num << 'III'
    when 4 
      num << 'IV'
    when 5 
      num << 'V'									#La funzione poteva essere implemantata con cicli for,
    when 6 											#divisioni, moduli e array con l'elenco delle lettere romane
      num << 'VI'									#ma abbiamo pensato che non sarebbe valsa la pena in quanto
    when 7 											#bastano 3 cicli case più una funzione per le migliaia
      num << 'VII'									#per definire tutti i numeri possibili.
    when 8 											
      num << 'VIII'									
    when 9 											
      num << 'IX'
  end
  return num
end

######
# Completa l'implementazione delle seguenti classi seguendo quanto
# richiesto dai commenti.
######

class Point2D
  attr_reader :x, :y
  
  def initialize(x, y)
    @x = x
    @y = y
  end
  
  def + (point)
    a = self.x + point.x
    b = self.y + point.y
    return Point2D.new(a,b)
  end

  def to_s
    return "(#{@x.round(15)},#{@y.round(15)})"						#'.round' è stato utilizzato per dei problemi
  end																#di approssimazione coi numeri float
end

require 'date' # necessario per l'uso della classe Date

class Book
  attr_accessor :title, :author, :release_date, :publisher, :isbn
  # Implementa il costruttore
  # dai un'occhiata a https://robots.thoughtbot.com/ruby-2-keyword-arguments
  def initialize(title:, author:, release_date:, publisher:, isbn:)
    @title=title
    @author=author
    @release_date=release_date
    @publisher=publisher
    @isbn=isbn
  end
  # requisiti perche' un libro sia considerato valido:
  # title deve essere una stringa (@title.class == String) non vuota
  # author deve essere una stringa non vuota
  # release_date deve essere un oggetto Date
  # publisher deve essere una stringa non vuota
  # isbn deve essere un Integer minore di 10**10 e maggiore di 10**9
  def valid?
    $errore=[]											#Utilizziamo una variabile globale in modo che la funzione
    if (title.class != String || title=='')				#'valid?' restituisca True o False ma possa passare gli 
      $errore << :title									#attributi non validi ad altre funzioni. La variabile 'errore'
    end													#viene posta come array vuoto per azzerare eventuali
    if (author.class != String || author=='')			#valori salvati precedentemente nella variabile
      $errore << :author
    end
    if !(release_date.is_a?Date)
      $errore << :release_date
    end
    if (publisher.class != String || publisher=='')
      $errore << :publisher
    end
    if (isbn.class != Fixnum  || isbn <= 10**9 || isbn >=10**10)
      $errore << :isbn
    end
    if $errore == []
      return TRUE
    else
      return FALSE
    end
  end
  # restituisce un array di simboli.
  # Se l'oggetto e' valido, restituisce un vettore vuoto
  # Se non lo e', per ogni attributo che non e' valido, la chiave per
  # quell'attributo deve essere presente nel vettore, in qualsiasi ordine.
  # esempio: title e author non sono validi, restituisce [:title, :author]
  def errors
    self.valid?
    return $errore
  end
end
